---
layout: post
title: 11. ë²¡í„°ì™€ í–‰ë ¬
katex: True
categories: [CK,ì—”ì§„ì‹¬í™”,assignment]
---

### ë¨¸ë¦¿ë§

â€¦ ì´ê±¸ í•œ ì£¼ ë§Œì— ë‹¤ í•œë‹¤ê³ ìš”..?

3ì£¼ì°¨ë¶€í„° 13ì£¼ì°¨ê¹Œì§€ í–ˆë˜ ë‚´ìš©ì´ í•œ ì£¼ì— ë“¤ì–´ê°‘ë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled.png)

ê³¼ê±°ì˜ ì§€ì‹ ON

(í•˜ì§€ë§Œ ì„¤ëª…ì˜ ë°©ì‹ë•Œë¬¸ì— ì‚¬ìš©í•  ì¼ì€ ì—†ì—ˆë‹¤)

## **Built-in shader variables**

[https://docs.unity3d.com/2021.2/Documentation/Manual/SL-UnityShaderVariables.html](https://docs.unity3d.com/2021.2/Documentation/Manual/SL-UnityShaderVariables.html)

# ë²¡í„°

> **ìˆ˜í•™ : 2ì£¼ì°¨ ê³¼ì œ ì¤‘ ì¼ë¶€**
ë²¡í„°ëŠ” í™”ì‚´í‘œì…ë‹ˆë‹¤.
ì–´ëŠ ë°©í–¥ìœ¼ë¡œ ì–¼ë§ˆë§Œí¼ ì´ë¼ëŠ” ì •ë³´ë¥¼ ê°€ì§„ í™”ì‚´í‘œ ì…ë‹ˆë‹¤.
ì´ í™”ì‚´í‘œì—ê²Œ í¬ê¸°ë¥¼ ëŠ˜ë¦°ë‹¤ëŠ”ê²ƒì€, 
ì§„í–‰í•˜ëŠ” ë°©í–¥ì„ í•˜ë‚˜ë¡œ ì¶•ìœ¼ë¡œ í•˜ëŠ” ì§ì„ ì—ì„œì˜ í¬ê¸°ë¥¼ ëŠ˜ë¦¬ëŠ” ê²ƒì…ë‹ˆë‹¤.

ì¦‰ ë²¡í„°ì˜ ê³µê°„ì€ 1ì°¨ì› ì§ì„ ì…ë‹ˆë‹¤.
> 

ì´ëŸ° ë²¡í„°ëŠ” ì •ë§ ë§ì€ ê³³ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

ìœ„ì¹˜ë¥¼ í‘œê¸°í•˜ê±°ë‚˜, ì´ë™í•˜ê±°ë‚˜, ìœ ì‚¬ë„ë¥¼ êµ¬í•˜ê±°ë‚˜ í•©ë‹ˆë‹¤.

ë²¡í„°ëŠ” ê° ì„±ë¶„ë³„ë¡œ êµ¬ì„±ë˜ì–´ ìˆëŠ”ë°,

ì‹¤ìˆ˜ N ì§‘í•©ì˜ ì›ì†Œë“¤ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ìˆœì„œìŒ ì´ë¼ê³  ìƒê°í•˜ë©´ ë˜ëŠ” ê²ƒì´ì£ .

## ë²¡í„°ì˜ ë§ì…ˆê³¼ ëº„ì…ˆ

ë²¡í„°ì™€ ë²¡í„°ì˜ ë§ì…ˆì€, ê° ìˆœì„œ(order)ì— ë§ëŠ” ìŠ¤ì¹¼ë¼ë¼ë¦¬ ë§ì…ˆì„ í•œ ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.

ë”°ë¼ì„œ  $$ (a,b) + (c,d) = (a+c,b+d) $$ ì…ë‹ˆë‹¤.

ë§ì…ˆì˜ ê°œë…ì—ì„œ í•©ì„±, ì¦‰ ì´ë™ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ëº„ì…ˆì€ ë§ì…ˆì˜ ì—­ì›ì„ ë”í•˜ëŠ” ê²ƒê³¼ ê°™ê¸° ë•Œë¬¸ì— 

 $$ 
(a,b) - (c,d) = (a+(-c),b+(-d)) \\ \therefore 
(a,b) - (c,d) = (a-c,b-d)
 $$ 

í•´ì£¼ë©´ ë©ë‹ˆë‹¤.

ëº„ì…ˆì˜ ê²½ìš°ì—ëŠ” ë³€ìœ„, ì¦‰ ì°¨ì´ë¥¼ ì•Œ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— 

íŠ¹ì • **ì **ì—ì„œ íŠ¹ì • **ì **ì„ ëº€ â€˜**ë°©í–¥**â€™ ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë²¡í„°ì˜ ìŠ¤ì¹¼ë¼ê³±

ë‹¤ì‹œ ëŒì•„ì™€ì„œ, ìŠ¤ì¹¼ë¼ë°°ëŠ” ìŠ¤ì¹¼ë¼ê°’ì„ ëª¨ë“  ìˆœì„œì˜ ë²¡í„°ë‚´ ìŠ¤ì¹¼ë¼ì— ê³±í•˜ë©´ ë©ë‹ˆë‹¤.

ë”°ë¼ì„œ   $$ (1,2)\space \alpha = (1 \space \alpha,2\space \alpha) $$ ì…ë‹ˆë‹¤

í•´ë‹¹ì—°ì‚°ì„ í†µí•´ 

- ë²¡í„°ì˜ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ í•˜ê±°ë‚˜(ìˆ˜ì§ì„ ì—ì„œ ë°©í–¥ì„ ë°˜ëŒ€ë¡œ í•œ ê²ƒê³¼ ê°™ì´)
- ë²¡í„°ì˜ ê¸¸ì´ë¥¼ ë³€í™”ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·¸ì € ì ìš©ë˜ëŠ”ê²Œ ìˆ˜ì§ì„ ì—ì„œ ë²¡í„°ê°€ ê°€ë¥´í‚¤ëŠ” ë°©í–¥ìœ¼ë¡œ ë°”ë€” ë¿ì…ë‹ˆë‹¤.

## ë²¡í„°ì˜ ì •ê·œí™”

ë²¡í„°ì˜ í¬ê¸°ë¥¼ 1ë¡œ ë§Œë“¤ê¸° ìœ„í•œ ì—°ì‚°ì…ë‹ˆë‹¤.

ë°©í–¥ë§Œì„ ê°€ë¦¬í‚¤ëŠ” ê²ƒì„ ì›í• ë•Œ êµ¬í•˜ê²Œ ë©ë‹ˆë‹¤.

êµ¬í•˜ëŠ” ê²ƒì€ ê° ì„±ë¶„ì˜ ì œê³±ì˜ í¬ê¸°ì˜ í•©ìœ¼ë¡œ ê° ì„±ë¶„ì„ ë‚˜ëˆ„ì–´ì¤ë‹ˆë‹¤.

ì‚¼ê°í˜•ì˜ ë¹—ë³€ì´ 1ì´ ë˜ê¸° ìœ„í•´ ê° ì„±ë¶„ì„ ì‚¼ê°í˜•ì˜ ë¹—ë³€ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” í–‰ë™ê³¼ ê°™ìŠµë‹ˆë‹¤.

ì½”ë“œë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```csharp
void Normalize(this Vector2 vector)
{
	  var norm = sqrt(vector.x * vector.x + vector.y * vector.y)
	  vector.x /= norm;
	  vector.y /= norm;
}
```

## ë²¡í„°ì˜ ë‚´ì 

ë‚´ì ì€ Cos, íˆ¬ì˜ì…ë‹ˆë‹¤.

êµí™˜ë²•ì¹™ì´ ì„±ë¦½í•˜ë©° 

ê²°í•©ë²•ì¹™ì€ ì„±ë¦½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ë¶„ë°°ë²•ì¹™ì€ ì„±ë¦½í•©ë‹ˆë‹¤

ë‘ ë²¡í„°ì˜ ë‚´ì ì€ ê° ë²¡í„°ì˜ í¬ê¸°ì˜ ê³±ì— cosğœ½í•œ ê°’ê³¼ ê°™ì€ë°,

ìì£¼ ì‚¬ìš©í•˜ëŠ” ë‚´ì ë“¤ì€ ë³´í†µ ì •ê·œí™” í•´ì„œ ì‚¬ìš©í•˜ë¯€ë¡œ cosğœ½ë§Œ ìƒê°í•˜ë©´ ë©ë‹ˆë‹¤.

ì´ë¥¼ ì‘ìš©í•˜ë©´ ì–´ë–¤ ì¼€ì´ìŠ¤ê°€ ìˆì„ê¹Œìš”? ë³´í†µ â€˜ê°ë„â€™ì— ëŒ€í•œ ê°’ìœ¼ë¡œ ìƒê°í•˜ë©´ ì¢‹ìŠµë‹ˆë‹¤.

ì‹œì•¼ê° ë‚´ì˜ ë¬¼ì²´íŒë³„ì„ ì˜ˆë¡œ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

![/assets/(Graphic)11/Untitled%201.png](/assets/(Graphic)11/Untitled%201.png)

**ì‹œì•¼ê° ë‚´ì˜ ë¬¼ì²´ íŒë³„**

1. ì‹œì•¼ê°ì˜ ê²½ìš°,  $$ \theta $$  degreeë¼ê³  ê°€ì •í•  ë•Œ,  $$ cos(\frac{\theta}{2}) $$  ê°’ì„ ë¯¸ë¦¬ êµ¬ì›Œë‘¡ë‹ˆë‹¤.
2. ê·¸ë¦¬ê³  ë¬¼ì²´ì˜ ìœ„ì¹˜(ì ) ì—ì„œ ì‹œì•¼ì˜ ìœ„ì¹˜(ì )ì„ ëº€ ë²¡í„°ë¥¼ êµ¬í•©ë‹ˆë‹¤.
3. ì‹œì•¼ì˜ ì •ë©´ ë²¡í„°ì™€ í•´ë‹¹ ë²¡í„°ë¥¼ ë‚´ì í•œ ê°’ì„ êµ¬í•©ë‹ˆë‹¤.
4. êµ¬ì›Œë‘” ì‹œì•¼ê°ì˜ ê°’ê³¼ 3.ì—ì„œ ë‚´ì í•œ ë²¡í„°ì˜ ê°’ì˜ ì°¨ì´ë¥¼ í†µí•´ ë‚´ë¶€ì™€ ì™¸ë¶€ë¥¼ íŒë³„í•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ì‹œì•¼ê° 60ë„ ì¼ ê²½ìš°, 30ì— í•´ë‹¹í•˜ëŠ” 0.866ì´ êµ¬ì›Œì§„ ê°’ì´ë©°,

ì‹œì•¼ì •ë©´ë²¡í„°ì™€, ì˜¤ë¸Œì íŠ¸ì™€ ì‹œì•¼ì˜ ë³€ìœ„ë²¡í„°ì˜ ë‚´ì ì„ í†µí•´ 0.866 ë³´ë‹¤ í¬ë‹¤ë©´ ì‹œì•¼ì— í¬í•¨,

0.866ë³´ë‹¤ ì‘ë‹¤ë©´ ì‹œì•¼ì— í¬í•¨ë˜ì§€ ì•ŠìŒ ì…ë‹ˆë‹¤.

ì‹œì•¼ê° ë¿ë§Œì´ ì•„ë‹Œ ë¹›ê³¼ í‘œë©´ì˜ ê°ë„, ë°±ì–´íƒ, 

ë­ ê·¸ëŸ° â€˜ê°ë„â€™ì— ëŒ€í•œ ê²ƒì„ ê³±ì…ˆê³¼ ë§ì…ˆë§Œìœ¼ë¡œ ê°€ë³ê²Œ êµ¬í•  ìˆ˜ ìˆì–´ ìì£¼ì‚¬ìš©í•©ë‹ˆë‹¤.

## ë²¡í„°ì˜ ì™¸ì 

ì™¸ì ì€ ì„ì˜ ë‘ ë²¡í„°ë¡œë¶€í„° ë˜ë‹¤ë¥¸ ë²¡í„°ëŸ‰ì„ ìƒì„±í•´ë‚´ëŠ” ì—°ì‚°ì…ë‹ˆë‹¤.

ê³„ì‚°í•˜ê³ ë‚˜ë©´ ë‚¨ëŠ”ê±´ ë‘ ë²¡í„°ì˜ í¬ê¸°ì˜ ê³±ì— sinğœ½ì— ë‘ ë²¡í„°ì˜ ìˆ˜ì§ ë°©í–¥ì„ ê³±í•œ ê¼´ì´ ë©ë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled%202.png)

ê¸°ë³¸ì ìœ¼ë¡œ êµí™˜ë²•ì¹™ì´ ë¹„ì„±ë¦½í•˜ë©°,

ê²°í•©ë²•ì¹™ë„ ë¹„ì„±ë¦½, ë¶„ë°°ë²•ì¹™ë§Œ ì„±ë¦½í•©ë‹ˆë‹¤.

ì—¬ê¸°ì„œ êµí™˜ë²•ì¹™ì„ ë‹¤ì‹œ í’€ì–´ë³´ë©´

![Untitled](/assets/(Graphic)11/Untitled%203.png)

ìˆœì„œê°€ ë°˜ëŒ€ë¡œ ëœ ê²ƒì„ ë³¼ ìˆ˜ ìˆëŠ”ë°, 

![Untitled](/assets/(Graphic)11/Untitled%204.png)

ê·¸ì— ë”°ë¼ ìœ„ ë‘ì‹ì´ ì¼ì¹˜í•œë‹¤ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì—¬ê¸°ì„œ **ë°˜ìˆ˜ì„±ì§ˆ** ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled%205.png)

ì™¸ì ì€ í™œìš©í•  ë•Œ ì¢Œìš°íŒë³„, ì•ë’¤íŒë³„ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì¢Œìš°íŒë³„**

ë°”ë¼ë³´ëŠ” ë°©í–¥ê³¼ ë¬¼ì²´ì˜ ë°©í–¥ì„ ì™¸ì í•œ ê°’ì€ upVectorì™€ í‰í–‰í•œ ë²¡í„°ê°€ ë‚˜ì˜¤ê²Œ ë˜ëŠ”ë°, 

ì´ë¥¼ ì„¤ì •í•˜ì—¬ ë‚´ì í•˜ì—¬ ìœ ì‚¬ë„ë¥¼ êµ¬í•œ ë‹¤ìŒ, ê·¸ ê°’ì˜ ë¶€í˜¸ë¡œ íŒë³„í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

ì¹´ë©”ë¼ì˜ ì—…ë²¡í„°ë¥¼ í†µí•´ ì¢Œ(subtractive)ì™€ ìš°(additive) ì˜ ìƒ‰ìƒì´ ë³€ê²½ë©ë‹ˆë‹¤.

![GIF.gif](/assets/(Graphic)11/GIF.gif)

**í›„ë©´ì»¬ë§**

í›„ë©´ì»¬ë§, ë°±í˜ì´ìŠ¤ ì»¬ë§ì€ ë‹¨ìˆœí•©ë‹ˆë‹¤.

ì¢Œí‘œê³„ì— ë”°ë¼ ì¸ë±ìŠ¤ë²„í¼ì— ì •ì  ì¸ë±ìŠ¤ë¥¼ ê°ê¸° ì‹œì‘í•œë‹¤ë©´

![Direct3D9, Left Handed](/assets/(Graphic)11/Untitled%206.png)
*Direct3D9, Left Handed*

![Untitled](/assets/(Graphic)11/Untitled%207.png)

ë‹¤ìŒê³¼ ê°™ì´ ë©ë‹ˆë‹¤.

ì´ ì„¸ì ì„ í†µí•´ ë‘ ë²¡í„°ë¥¼ êµ¬í•˜ê³ , ë‘ ë²¡í„°ì˜ ì™¸ì ì„ í†µí•´ ë©´ì˜ ë…¸ë©€ì„ êµ¬í•©ë‹ˆë‹¤.

ë©´ì˜ ë…¸ë©€ì„ êµ¬í–ˆìœ¼ë©´ ì–´ëŠë°©í–¥ìœ¼ë¡œ ë‚˜ê°€ëŠ”ì§€ ì•Œê¸°ë•Œë¬¸ì—, ë’·ë©´ì„ ëª¨ë‘ ì•ˆê·¸ë¦´ ìˆ˜ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤.

shader graphë¡œ ëŒ€ì¶© í…ŒìŠ¤íŠ¸í•´ë´…ì‹œë‹¤.

Two Side (ì–‘ë©´ë Œë”ë§) Lit ì‰ì´ë”ë¥¼ í•˜ë‚˜ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.

ì–‘ë©´ì„ ë³´ì—¬ì¤˜ì•¼ í•˜ë‹ˆê¹Œ Transparent, ì–‘ë©´ì„ ë³´ì—¬ì¤˜ì•¼ í•˜ë‹ˆê¹Œ TwoSide.

![Untitled](/assets/(Graphic)11/Untitled%208.png)

ê·¸ëŸ¼ ì´ëŸ°ê²Œ ë‚˜ì˜µë‹ˆë‹¤. 

![Untitled](/assets/(Graphic)11/Untitled%209.png)

ê·¸ëŸ¬ë©´ ì´ì œ ìœ„ì—ì„œ ì„¤ëª…í•œëŒ€ë¡œ ë§Œë“¤ì–´ ë³¼ê¹Œìš”?

![Untitled](/assets/(Graphic)11/Untitled%2010.png)

ì¹´ë©”ë¼ì—ì„œ í•´ë‹¹ ë©´(ì—¬ê¸°ì„œëŠ” í”½ì…€ì…ë‹ˆë‹¤)ì˜ ë°©í–¥(Position - CameraPosition)ê³¼ 
ë…¸ë©€(Normal)ì„ ë‚´ì í•©ë‹ˆë‹¤.

ê·¸ë¦¬ê³  ê·¸ ê°’ì´ 0ë³´ë‹¤ ì‘ì€ ê°’ë“¤, ì¦‰ ë§ˆì£¼ë³´ëŠ” ë°©í–¥ì— ë”°ë¼

![Untitled](/assets/(Graphic)11/Untitled%2011.png)

ë§ˆì£¼ë³¸ë‹¤ë©´ 1, ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ 0ì˜ ê°’ì„ íˆ¬ëª…ë„ì— ê³±í•©ë‹ˆë‹¤.

ê·¸ëŸ¬ë©´ ì§ . 

![Untitled](/assets/(Graphic)11/Untitled%2012.png)
*ë¼ì´íŠ¸ ìƒ‰ìƒ ì¢€ ì˜ ë°›ëŠ” ê°ë„ë¡œ ì¹´ë©”ë¼ë¥¼ ì˜®ê²¼ìŠµë‹ˆë‹¤. ì™œ ìƒ‰ìƒì´ ê¸°ì¦ˆëª¨ë¥¼ ì•ˆë”°ë¥´ëƒê³ ìš”? ì œ ë§˜ì…ë‹ˆë‹¤.*

![Untitled](/assets/(Graphic)11/Untitled%2013.png)

ì§€ê¸ˆì€ ì‹œê°ì ìœ¼ë¡œ ë³´ì´ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•´ íˆ¬ëª…ë„ë¥¼ 0ìœ¼ë¡œ ì„¤ì •í•˜ì˜€ì§€ë§Œ,

ì‹¤ì œ ì—°ì‚°ì€ ë¹„êµ(Comparison)ë¥¼ í†µí•´ ì–»ì€ ê°’ì— ë”°ë¼ ë Œë”ë§ í• ì§€ì— ëŒ€í•œ ì—¬ë¶€ë¥¼ ê³ ë¥´ë©´ ë©ë‹ˆë‹¤.

![ìœ„: URP lit Transparent alpha twoside
ì¤‘ê°„ : URP lit Transparent alpha front
ì•„ë˜ : êµ¬í˜„ë¬¼](/assets/(Graphic)11/Untitled%2014.png)

ìœ„: URP lit Transparent alpha twoside
ì¤‘ê°„ : URP lit Transparent alpha front
ì•„ë˜ : êµ¬í˜„ë¬¼

![êµ¬í˜„ëœ ì»¬ë§ì²˜ëŸ¼ ë³´ì´ëŠ” ê·¸ê²ƒ](/assets/(Graphic)11/Untitled%2015.png)
*êµ¬í˜„ëœ ì»¬ë§ì²˜ëŸ¼ ë³´ì´ëŠ” ê·¸ê²ƒ*

## í‘œì¤€ê¸°ì €ë²¡í„°

[ê¸°ì €ë²¡í„°ë¥¼ ì´í•´í•˜ê¸° ê°€ì¥ ì¢‹ì€ ìœ íˆ¬ë¸Œ ìë£Œ](https://youtu.be/k7RM-ot2NWY)
*ì¼ë‹¨ ë“œì…”ë³´ì‹­ì‡¼! ì´ê²Œ ë‹µì…ë‹ˆë‹¤!*

### ê¸°ì €ì™€ ê¸°ì €ë²¡í„°

ì„ì˜ì˜ ë²¡í„°ë“¤ì´ ì„ í˜•ì˜ì¡´ê´€ê³„ê°€ ì•„ë‹ˆë¼ë©´ ìƒì„±ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤

ì´ ìƒì„±ì´ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” ë²¡í„°ë“¤ì„ **ê¸°ì €ë²¡í„°(basis vector)** ë¼ê³  í•©ë‹ˆë‹¤. 

ê·¸ë¦¬ê³  ì´ ì„ í˜•ë…ë¦½ì¸ ë²¡í„°ë“¤ì˜ ì§‘í•©ì„ **ê¸°ì €(basis)**ë¼ê³  í•©ë‹ˆë‹¤.

### í‘œì¤€ê¸°ì €ë²¡í„°

ê·¸ë¦¬ê³  **í‘œì¤€ê¸°ì €ë²¡í„°(Standard Basis Vector)** ë¼ëŠ” ì¡´ì¬ê°€ ìˆìŠµë‹ˆë‹¤.

ì•„ê¹Œ ìœ„ì—ì„œ ì„¤ëª…í•˜ì˜€ë˜ ë‹¨ìœ„ë²¡í„°ì˜ ê¸°ì €ë²¡í„° ë²„ì „ì´ë¼ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.

ê³„ì‚°ì„ í¸ë¦¬í•˜ê²Œ ë§Œë“¤ê³ , ê°€ì¥ ê°œë…ì ìœ¼ë¡œ íƒ€ì´íŠ¸í•˜ê¸° ì‰¬ìš´ ë²¡í„°ì´ë©°,

ì„±ë¶„ 1ê°œë§Œì´ 1ì´ë©° ë‚˜ë¨¸ì§€ ì„±ë¶„ì´ ëª¨ë‘ 0ì¸ ë²¡í„°ì…ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë°ì¹´ë¥´íŠ¸ ì¢Œí‘œê³„ì—ì„œëŠ” (1,0) , (0,1) ì˜ ë‘ ê°œì˜ ë²¡í„°ê°€ 
í‘œì¤€ ê¸°ì €ë²¡í„°ì…ë‹ˆë‹¤.

ì´ í‘œì¤€ ê¸°ì € ë²¡í„°ë¥¼ í†µí•´ ì¢Œí‘œì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  ì§€ì ì„ 
ê°ê°ì˜ ì„±ë¶„ì— ìŠ¤ì¹¼ë¼ë°°ë¥¼ í•œ ê°’ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# í–‰ë ¬

### í–‰ë ¬ì´ë€ ë¬´ì—‡ì¸ê°€?

ìˆ˜ë¥¼ 1ì°¨ì›ì ìœ¼ë¡œ ë‚˜ì—´í•œ ì²´ê³„ë¥¼ ë²¡í„°ë¼ê³  í•˜ì˜€ë‹¤ë©´, 
ìˆ˜, ë¬¸ì, í•¨ìˆ˜ë“±ì„ ë„¤ëª¨ê¼´ ê´„í˜¸ ì•ˆì— ë°°ì—´í•˜ì—¬ 2ì°¨ì› ë†“ì€ ê²ƒì´ í–‰ë ¬ì…ë‹ˆë‹¤.

ì„ í˜•ë³€í™˜(Linear Transformation)ë¥¼ ì¢€ ë” í¸í•˜ê²Œ í•˜ê¸° ìœ„í•˜ì—¬ ë‹¨ìˆœí™” ì‹œí‚¨ ë„êµ¬ë¼ê³ í•©ë‹ˆë‹¤.

í–‰(row)ê³¼ ì—´(column)ì„ ê°€ì§€ê³  ìˆìœ¼ë©°  ë‹¤ìŒê³¼ ê°™ì´ í‘œê¸°í•©ë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled%2016.png)

ë˜í•œ í–‰ì´ í•˜ë‚˜ì´ê±°ë‚˜, ì—´ì´ í•˜ë‚˜ì¸ ê²½ìš°ë¥¼ ë³¼ ìˆ˜ ìˆëŠ”ë°, ëª¨ìŠµì´ ë§ˆì¹˜ ë²¡í„°ì™€ ê°™ìŠµë‹ˆë‹¤.

ê·¸ë¦¬ê³  ì´ê±¸ ìˆ˜í•™ì ìœ¼ë¡œ í–‰ì´ í•˜ë‚˜ì¸ í–‰ë ¬ì€ í–‰ë²¡í„°(row vector) 

![Untitled](/assets/(Graphic)11/Untitled%2017.png)

ì—´ì´ í•˜ë‚˜ì¸ í–‰ë ¬ì€ ì—´ë²¡í„°(column vector)

![Untitled](/assets/(Graphic)11/Untitled%2018.png)

ë¼ê³  í•©ë‹ˆë‹¤.

## í–‰ë ¬ì˜ ë§ì…ˆ,ëº„ì…ˆ ê·¸ë¦¬ê³  ìŠ¤ì¹¼ë¼ê³±

ë§ì…ˆê³¼ ëº„ì…ˆì€ ë‹¨ìˆœíˆ ë˜‘ê°™ì€ ìœ„ì¹˜ì— ë˜‘ê°™ì€ ê°’ì„ â€˜ì—°ì‚°â€™í•©ë‹ˆë‹¤.

í•˜ì§€ë§Œ ê³±ì…ˆì€ ì¡°ê¸ˆ ë‹¤ë¦…ë‹ˆë‹¤.

í–‰ë ¬ì˜ ê³±ì…ˆì€ ì„ í˜•ë³€í™˜ì— ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ìˆ˜í•™ì  ë„êµ¬ë¼ê³  í•˜ì˜€ëŠ”ë°,

ì •í™•íˆ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ ë³¸ë‹¤ë©´ ê·¸ ì˜ë¯¸ë¥¼ ì•Œ ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ ìŠ¤ì¹¼ë¼ì™€ í–‰ë ¬ì˜ ê³±ì€ ë‹¨ìˆœí•˜ê²Œë„ ëª¨ë“  ì›ì†Œì— ëŒ€í•´ ìŠ¤ì¹¼ë¼ë°° í•´ì£¼ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ë§ˆì¹˜ ë²¡í„°ì—ì„œì˜ ìŠ¤ì¹¼ë¼ë°°ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë§ì´ì£ .

 $$ 
\bold A  = \begin{bmatrix}
a & b\\
c & d
\end{bmatrix}
\\
k\bold A = \begin{bmatrix}
ka & kb\\
kc & kd
\end{bmatrix}
 $$ 

ê·¸ë¦¬ê³  ë©”ì¸ì¸ í–‰ë ¬ê³¼ í–‰ë ¬ì˜ ê³±ì…ˆì„ ì•Œì•„ë´…ì‹œë‹¤.

ê°„ë‹¨í•˜ê²Œ í–‰ë ¬ì˜ ê³±ì€, í–‰ê³¼ ì—´ë¼ë¦¬ ê³±ì—°ì‚°í•œ ê²°ê³¼ì˜ í•©ì„ ì €ì¥í•©ë‹ˆë‹¤.

í–‰ë ¬  $$ \bold A $$ ì™€  $$ \bold B $$ ì˜ ê³±ì€  $$ \bold{AB} $$ ë¡œ ì“°ê³ , ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•©ë‹ˆë‹¤.

> " $$ \bold{AB}(i,j) $$ ëŠ”,  $$ \bold A $$ ì˜  $$ i $$  ë²ˆì§¸ í–‰ì´ ì´ë£¨ëŠ” í–‰ë²¡í„°ì™€
 $$ \bold B $$ ì˜  $$ j $$ ë²ˆì§¸ ì—´ì´ ì´ë£¨ëŠ” ì—´ë²¡í„°ì˜ ë‚´ì ì´ë‹¤"
> 

ë¬´ìŠ¨ì†Œë¦¬ëƒê³ ìš”? 

![/assets/(Graphic)11/assignment_GIF_5.gif](/assets/(Graphic)11/assignment_GIF_5.gif)

ì´ê²ƒì€ ì²˜ë¦¬ë¥¼ ì‹œê°ì ìœ¼ë¡œ ë³´ì—¬ì¤€ ê²ƒì…ë‹ˆë‹¤.

## ê¸°ì €ë²¡í„°ë¥¼ í†µí•œ í–‰ë ¬, ê³µê°„êµ¬ì„±

ì•„ê¹Œ ì„¤ëª…í–ˆë˜ ê¸°ì €ë²¡í„°ë¥¼ ëŠ˜ì–´ë†“ê²Œ ëœë‹¤ë©´ í•˜ë‚˜ì˜ í–‰ë ¬ì´ êµ¬ì„±ë˜ëŠ”ë°,

ê¸°ì¡´ í¬ê¸° * ê¸°ì €A + í¬ê¸° * ê¸°ì €B ì˜ í˜•íƒœì—ì„œ ê¸°ì €ë§Œ ë³€í˜•ëœ ê²ƒì´ê¸° ë•Œë¬¸ì—

ì´ë¥¼ ê¸°ì €ë²¡í„°ë¡œ êµ¬ì„±ëœ í•˜ë‚˜ì˜ ê³µê°„ì´ë¼ê³  ë³´ì•„ë„ ê´œì°®ìŠµë‹ˆë‹¤.

## íŠ¸ëœìŠ¤í¼ê³¼ ê³µê°„ë³€í˜•

ê·¸ì „ì— ê° ê³µê°„ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤.

### ì˜¤ë¸Œì íŠ¸ ì¢Œí‘œê³„ (Object space, ë¡œì»¬ì¢Œí‘œê³„ í˜¹ì€ ëª¨ë¸ì¢Œí‘œê³„)

ê° ì˜¤ë¸Œì íŠ¸ì˜ ì¤‘ì‹¬ì´ ë˜ëŠ” ì¢Œí‘œê³„ì…ë‹ˆë‹¤.

### ì›”ë“œ ì¢Œí‘œê³„ (World Space)

ì›”ë“œì¢Œí‘œê³„ëŠ” Sceneì˜ ì¤‘ì‹¬ì ì„ ì¤‘ì‹¬ìœ¼ë¡œí•˜ì—¬ Sceneì•ˆì—ì„œ ì—¬ëŸ¬ê°œì˜ ì˜¤ë¸Œì íŠ¸ê°€ ê³µê°„ì ìœ¼ë¡œ ì–´ëŠì •ë„ ê´€ê³„ê°€ ìˆëŠ”ê°€ë¥¼ í‘œì‹œí•˜ëŠ” ì¢Œí‘œê³„ì…ë‹ˆë‹¤. 

ì˜¤ë¸Œì íŠ¸ì˜ ì´ë™ íšŒì „ í¬ê¸°ë¥¼ ë‹¤ë£¨ëŠ” ModelingTransformì— ì˜í•´ ì˜¤ë¸Œì íŠ¸ ê³µê°„ìœ¼ë¡œë¶€í„° ë³€í™˜ë©ë‹ˆë‹¤. 

### ë·° ì¢Œí‘œê³„(View Space, ì‹œì  í˜¹ì€ ì¹´ë©”ë¼ ì¢Œí‘œê³„)

ë·° ì¢Œí‘œê³„ëŠ” ë Œë”ë§í•˜ëŠ” ì¹´ë©”ë¼ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ê·¸ ì‹œì ì„ ì¤‘ì‹¬ì ìœ¼ë¡œ ì„¤ì •í•œ ì¢Œí‘œê³„ì…ë‹ˆë‹¤.

ì¹´ë©”ë¼ì˜ ìœ„ì¹˜, ì¹´ë©”ë¼ì˜ ì—…ë²¡í„°, ì¹´ë©”ë¼ì˜ ë°”ë¼ë³´ëŠ” ë°©í–¥ ë“±ì˜ ì •ë³´ë¥¼ ì •ì˜í•œ ë·° í–‰ë ¬ì´ ì¡´ì¬í•˜ëŠ”ë°,

ì´ë¥¼ ì´ìš©í•˜ì—¬ ì›”ë“œ ì¢Œí‘œê³„ì—ì„œ View Transformì— ì˜í•´ View Spaceë¡œ ë³€í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### í´ë¦½ ì¢Œí‘œê³„(Clip Space)

í´ë¦½ ì¢Œí‘œê³„ëŠ” ìœ„ì—ì„œ ì‚¬ìš©í•œ ViewMatrixì— ì •ì˜í•œ ì¹´ë©”ë¼ ì™¸ì˜ ì •ë³´ë¥¼ ì¶”ê°€í•œ 

Projection Matrixë¥¼ ë·° ì¢Œí‘œê³„ì—ì„œ ê³„ì‚°í•˜ì—¬ ì–»ì–´ì§€ëŠ” ì¢Œí‘œê³„ì…ë‹ˆë‹¤.

Projection MatrixëŠ” FOV, ì¢…íš¡ë¹„, near clip, far clipë“±ì˜ ì •ë³´ë¥¼ ì¶”ê°€ë¡œ ì •ì˜í•˜ë©°,

ì´ í–‰ë ¬ì„ ì ìš©í•˜ëŠ” ê³„ì‚°ì„ Projection Transformì´ë¼ í•©ë‹ˆë‹¤.

ìµœì¢…ì ìœ¼ë¡œ ì¹´ë©”ë¼ì˜ ë Œë”ë§ ê³µê°„ì„ í´ë¦¬í•‘í•©ë‹ˆë‹¤.

### ë™ì°¨ ì¢Œí‘œê³„ (Homogeneous Coordinates)

3ì°¨ì›ì˜ ìœ„ì¹˜ê°’ì€ (x,y,z) ì´ì§€ë§Œ ê°€ë” (x,y,z,w)ì˜ í˜•íƒœì²˜ëŸ¼ 

4ì°¨ì›ìœ¼ë¡œ ì·¨ê¸‰í•´ì•¼í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤ (ì•„í•€ê³µê°„ ì²˜ëŸ¼ìš”)

ì´ë ‡ê²Œ ë‚˜íƒ€ë‚¸ ì¢Œí‘œë¥¼ ë™ì°¨ ì¢Œí‘œë¼ê³  ë¶€ë¦…ë‹ˆë‹¤(1ì°¨,2ì°¨ ë°©ì •ì‹ì²˜ëŸ¼ ì°¨ê°€ ê°™ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤).

ì´ë ‡ê²Œ ìœ„ì¹˜ë¥¼ 4ì°¨ì›ìœ¼ë¡œ ë³€í™˜í•˜ëŠ”ê²ƒìœ¼ë¡œ 4x4 í–‰ë ¬ì— íš¨ê³¼ì ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ”ê²ƒì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ì¢Œí‘œë³€í™˜ì˜ ê³„ì‚°ì€ ê¸°ë³¸ì ìœ¼ë¡œ 4x4í–‰ë ¬ë¡œ ê³„ì‚°í•˜ë¯€ë¡œ, ìœ„ì¹˜ë²¡í„°ëŠ” ì´ì²˜ëŸ¼ 4ì°¨ì›ìœ¼ë¡œ í‘œí˜„í•©ë‹ˆë‹¤ (ì•„í•€ê³µê°„ì˜ ì ì˜ ì´ë™ì„ ìƒê°í•´ë³¸ë‹¤ë©´ ì°¨ì›ë³´ë‹¤ 1ë‹¨ê³„ ë†’ì€ í–‰ë ¬ì´ í•„ìš”í•©ë‹ˆë‹¤)

ë™ì°¨ì™€ ë¹„ë™ì°¨ì˜ ë³€í™˜ì€ (x/w, y/w, z/w, 1) = (x,y,z,w) ì˜ ì‹ê³¼ ê°™ì´ ì´ë£¨ì–´ ì§‘ë‹ˆë‹¤.

### NDC ì¢Œí‘œê³„(Normalized Device Coordinates)

Clip ì¢Œí‘œê³„ì— ì˜í•´ ê³„ì‚°ëœ ì¢Œí‘œì˜ ì„±ë¶„ì— wë¥¼ ë‚˜ëˆ„ëŠ” ê²ƒìœ¼ë¡œ 

-1<ì„±ë¶„<1 ì˜ ê°’ìœ¼ë¡œ ëª¨ë“  ì„±ë¶„ì„ ì •ê·œí™”í•©ë‹ˆë‹¤. 

ì´ ê³„ì‚°ìœ¼ë¡œ êµ¬í•  ìˆ˜ ìˆëŠ” ì¢Œí‘œê³„ë¥¼ NDC ì¢Œí‘œê³„ë¼ê³  í•©ë‹ˆë‹¤. 

ì´ ë³€í™˜ì€ Perspective divideë¼ê³  ë¶ˆë¦¬ë©° ë§ì—ì„œ ì•Œì•„ì±Œ ìˆ˜ ìˆë“¯ ì›ê·¼ì— ë”°ë¼ ì•ì˜ ì˜¤ë¸Œì íŠ¸ëŠ” í¬ê²Œ, ë©€ë¦¬ìˆëŠ” ì˜¤ë¸Œì íŠ¸ëŠ” ì‘ê²Œ í‘œí˜„ë©ë‹ˆë‹¤.

### ìŠ¤í¬ë¦° ì¢Œí‘œê³„ (Screen Space)

NDC ì¢Œí‘œê³„ì˜ ìˆ˜ì¹˜ë¥¼ í™”ë©´ í•´ìƒë„ì— ë§ê²Œ ë³€í™˜í•œ ì¢Œí‘œê³„ì…ë‹ˆë‹¤.

# ì‹¤ìŠµ - í¬ìŠ¤íŠ¸í”„ë¡œì„¸ì‹±ì„ í†µí•œ ìƒ‰ìƒë³€ê²½

---

ì´ë²ˆì—” í¬ìŠ¤íŠ¸í”„ë¡œì„¸ì‹±ì„ ê±´ë“œë ¤ë³¼ ìƒê°ì…ë‹ˆë‹¤.

ê·¸ê²ƒë„ ë Œë” íŒŒì´í”„ë¼ì¸ì— ë Œë”í”¼ì²˜ë¥¼ ë„£ì–´ì„œìš”.

![Untitled](/assets/(Graphic)11/Untitled%2019.png)

ìµœì¢…ì ìœ¼ë¡  ìœ„ê³¼ ê°™ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.

ë Œë” í”¼ì²˜ì—ì„œ í”„ë ˆì„ ë²„í¼ë¥¼ ë°›ì•„ì™€ ë Œë” í…ìŠ¤ì²˜ì— í•œë²ˆ ì‘ì„±í•œ ë‹¤ìŒ, 

í•´ë‹¹ í…ìŠ¤ì²˜ë¥¼ ì´ë²ˆì—” ë¨¸í…Œë¦¬ì–¼ì„ í†µí•´ í”„ë ˆì„ë²„í¼ì— ë‹¤ì‹œ ë Œë”ë§í•©ë‹ˆë‹¤.

ì´ ë¨¸í…Œë¦¬ì–¼ì€ vertex fragment ì‰ì´ë”ì— mainTexture í•˜ë‚˜ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.

ê·¸ë¦¬ê³  ì´ ë¨¸í…Œë¦¬ì–¼ì€ ì„¸ê°€ì§€ ê¸°ì € ìƒ‰ìƒì„ ë‚˜íƒ€ë‚´ë©°,

![Untitled](/assets/(Graphic)11/Untitled%2020.png)

![Untitled](/assets/(Graphic)11/Untitled%2021.png)

ìƒ‰ìƒì„ ë³€ê²½í•  ê²½ìš° ìµœì¢…ì ìœ¼ë¡œ í™”ë©´ì— ê·¸ë ¤ì§€ëŠ” ìƒ‰ìƒì€

'ê¸°ì € ì„¸ê°œë¡œ êµ¬ì„±ëœ í–‰ë ¬ì˜ ì „ì¹˜í–‰ë ¬(ì„ ì–¸ì‹œ ê·¸ëƒ¥ ë°”ë¡œ ë„£ì—ˆë‹¤ëŠ” ëœ»)'ì„ ê³±í•˜ì—¬,

ìƒˆë¡œìš´ ê¸°ì €ì— ë§ëŠ” ìƒ‰ìƒìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

!['ê¸°ì €ë²¡í„°' ë¡œì¨ ì‚¬ìš©í•˜ìë©´ transposeí•œê²Œ ë§ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.í•˜ì§€ë©´ ì´ë²ˆì—” ê·¸ëƒ¥ ì‚¬ìš©í•©ë‹ˆë‹¤.](/assets/(Graphic)11/image.png)
*'ê¸°ì €ë²¡í„°' ë¡œì¨ ì‚¬ìš©í•˜ìë©´ transposeí•œê²Œ ë§ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.í•˜ì§€ë©´ ì´ë²ˆì—” ê·¸ëƒ¥ ì‚¬ìš©í•©ë‹ˆë‹¤.*

![Untitled](/assets/(Graphic)11/Untitled%2022.png)

![Untitled](/assets/(Graphic)11/Untitled%2023.png)

![Untitled](/assets/(Graphic)11/Untitled%2024.png)

![Untitled](/assets/(Graphic)11/Untitled%2025.png)

![Untitled](/assets/(Graphic)11/Untitled%2026.png)

```csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class FinalRenderFeature : ScriptableRendererFeature
{

    [System.Serializable]
    public class FinalSettings
    {
        public RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingTransparents;
        public Material passMaterial = null;
    }

    public FinalSettings settings = new FinalSettings();

    class FinalRenderPass : ScriptableRenderPass
    {

        public Material passMaterial;
        string profilerTag;

        int tmpId1;

        RenderTargetIdentifier tmpRT1;
        RenderTargetIdentifier cameraColorTexture;

        public FinalRenderPass(string profilerTag)
        {
            this.profilerTag = profilerTag;
        }

        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
        {
            tmpId1 = Shader.PropertyToID("tmpBlurRT1");

            cmd.GetTemporaryRT(tmpId1, cameraTextureDescriptor.width, cameraTextureDescriptor.height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32);

            tmpRT1 = new RenderTargetIdentifier(tmpId1);

            ConfigureTarget(tmpRT1);
        }

        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
        {
            cameraColorTexture = renderingData.cameraData.renderer.cameraColorTarget;
            CommandBuffer cmd = CommandBufferPool.Get(profilerTag);

            RenderTextureDescriptor opaqueDesc = renderingData.cameraData.cameraTargetDescriptor;
            opaqueDesc.depthBufferBits = 0;

            cmd.Blit(cameraColorTexture, tmpRT1);
            cmd.Blit(tmpRT1, cameraColorTexture, passMaterial);

            context.ExecuteCommandBuffer(cmd);
            cmd.Clear();

            CommandBufferPool.Release(cmd);
        }

        public override void FrameCleanup(CommandBuffer cmd)
        {

        }
    }

    // Unity RenderPipeline

    private FinalRenderPass scriptablePass;

    public override void Create()
    {
        scriptablePass = new FinalRenderPass("Final");
        scriptablePass.passMaterial = settings.passMaterial;
        scriptablePass.renderPassEvent = settings.renderPassEvent;
    }

    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
    {
        renderer.EnqueuePass(scriptablePass);
    }
}
```

```glsl
Shader "Hidden/FinalShader"
{
    Properties
    { 
        [HideInInspector]_MainTex ("Texture", 2D) = "white" {}
        _Axis_R ("Axis R", Color) = (1,0,0,1)
        _Axis_G ("Axis G", Color) = (0,1,0,1)
        _Axis_B ("Axis B", Color) = (0,0,1,1)
    }

    SubShader
    {
        Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalRenderPipeline" }

        Cull Off ZWrite Off ZTest Always
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"            

            struct Attributes
            {
                float4 positionOS   : POSITION;      
                float2 uv : TEXCOORD0;           
            };

            struct Varyings
            {
                float2 uv : TEXCOORD0;
                float4 positionHCS  : SV_POSITION;
            };            

            CBUFFER_START(UnityPerMaterial)
                sampler2D _MainTex;
                float4 _Axis_R;
                float4 _Axis_G;
                float4 _Axis_B;
            CBUFFER_END

            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = IN.uv;
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target
            {
                float4 col = tex2D(_MainTex, IN.uv);

                float3x3 colorMatrix = float3x3(
                    _Axis_R.rgb,
                    _Axis_G.rgb,
                    _Axis_B.rgb
                );

                col.rgb = mul(colorMatrix,col.rgb);
                return col;
            }
            ENDHLSL
        }
    }
}
```

ìµœì¢…ì ìœ¼ë¡œ ë½‘ì•„ë³¸ í™”ë©´ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

![image1](/assets/(Graphic)11/image1.png)

![image2](/assets/(Graphic)11/image2.png)

# ì‹¤ìŠµ(?) - í’€ ì‰ì´ë” ìƒí˜¸ì‘ìš©

(ì´ë¼ì“°ê³  ê·¸ëƒ¥ í•˜ê³  ì‹¶ì€ê±° í•œ ê²ƒ ìë‘)

![Untitled](/assets/(Graphic)11/Untitled%2027.png)

ì‚¬ì‹¤ ì €ë²ˆì£¼ì— ì‘ì„±í•œ í’€ ì‰ì´ë”ì—ì„œ, 

ëª¨ë“  ê³µê°„ë³€í™˜ì´ ì´ë²ˆì£¼ì°¨ì— ë°°ìš´ ë‚´ìš©ì´ê¸° ë•Œë¬¸ì— ì¢€ ë‹¤ì‹œì½ìœ¼ë©´ í¥ë¯¸ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•„ë¬´íŠ¼ ì €ë²ˆì£¼ ê³¼ì œë¬¼ì„ ì™„ì„±í•œ í›„, ì ì„ ìë‹¤ê°€ ê·¸ëŸ°ìƒê°ì„ í–ˆìŠµë‹ˆë‹¤.

ì–´? ë§ˆìŠ¤í¬ë§µì´ ìˆìœ¼ë©´, ê·¸ëƒ¥ í…ìŠ¤ì²˜í•˜ë‚˜ ê·¸ë ¤ì„œ í’€ì„ ì§€ìš°ê±°ë‚˜, ëˆŒë¦¬ê±°ë‚˜ í•  ìˆ˜ ìˆëŠ”ê±° ì•„ë‹Œê°€?

ê·¸ë ‡ê²Œ ë¨¸ë¦¿ì†ìœ¼ë¡œ ê³°ê³°íˆ ì˜ ìˆ™ì„±í•˜ë‹¤ê°€ ê°œë°œì„ ì§„í–‰í•´ ë³´ì•˜ìŠµë‹ˆë‹¤.

ê³¨ìëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

ë§Œì•½ ê³µê²©ì´ ë°œìƒí•œë‹¤ë©´, í•´ë‹¹ì§€ì ì— raycastë¥¼ ì‚¬ìš©í•˜ì—¬ uvì¢Œí‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

ë§µì— ì‚¬ìš©ë  ë Œë”í…ìŠ¤ì²˜ì˜ uvì¢Œí‘œì— ìƒ‰ì„ ì¹ í•©ë‹ˆë‹¤.

### 1. ìƒí˜¸ì‘ìš©í•  ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°

![Untitled](/assets/(Graphic)11/Untitled%2028.png)

ê°„ë‹¨í•˜ê²Œ ì˜¤ë¸Œì íŠ¸ê°€ ìœ„ì¹˜í•œ ì§€ì ì˜ uvë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

í•´ë‹¹uvì— ì ì ˆí•˜ê²Œ ìƒ‰ì„ ì¹ í•´ì¤˜ì•¼í•˜ëŠ”ë°, uvëŠ” [0~1]ì˜ ê°’ì„ ê°€ì§€ê³ ,

í”½ì…€ì€ í™”ì†Œ, ì¦‰ ì •ìˆ˜ ë‹¨ìœ„(1,2,3..)ì˜ êµ¬ì„±ì´ë¯€ë¡œ 

í…ìŠ¤ì²˜ ì‚¬ì´ì¦ˆì™€ ë©”ì‰¬ì˜ ë°”ìš´ë“œì™€ íŠ¸ëœìŠ¤í¼ì˜ í¬ê¸°ë¥¼ ê°€ì ¸ì™€ì„œ ì ë‹¹íˆ ì˜ ì„ì–´ì¤ë‹ˆë‹¤.

### 2. ì¹ í•˜ê¸°

ì§€ê¸ˆ ê°€ì ¸ì˜¨ê±´ í•˜ë‚˜ì˜ í”½ì…€ì´ë¯€ë¡œ, ëŒ€ëµ ë„ˆë¹„ë¥¼ ì§€ì •í•´ì„œ ê·¸ ì˜ì—­ì„ ë‹¤ ì¹ í•˜ê²Œ í•©ë‹ˆë‹¤.

ì›ì„ ê·¸ë¦¬ëŠ” ë°©ë²•ìœ¼ë¡œ í•´ë„ë˜ê³  ë­˜ë¡œí•´ë„ ë˜ëŠ”ë°, ì €ëŠ” ì˜ˆì œê°€ íë¸Œì´ê¸° ë•Œë¬¸ì— ì‚¬ê°í˜•ìœ¼ë¡œ ì¹ í•©ë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled%2029.png)

ìƒ‰ì„ ì¹ í• ë•ŒëŠ” ê³ ë ¤í•´ì•¼í•  ì‚¬í•­ì´ ì¡°ê¸ˆ ìˆìŠµë‹ˆë‹¤.

ì¹ í• ë•Œì˜ ìœ„ì¹˜ê°€ ë§Œì•½ 0ì´ë‚˜ í…ìŠ¤ì²˜ì˜ í¬ê¸°ê°€ ë„˜ì–´ê°€ë©´, ë°˜ëŒ€ìª½ ë¶€ë¶„ì— ê·¸ë ¤ì§„ë‹¤ëŠ” ì ì¸ë°ìš”,

ì•½ê°„ ìœ ì‚¬-repeat ê°™ì€ëŠë‚Œì˜ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.

ê·¸ëŸ¬ë‹ˆ Clamp ì²˜ë¦¬ë¥¼í•´ì„œ ì‚ì ¸ë‚˜ê°€ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.

ê·¸ëŸ¬ë©´ í…ìŠ¤ì³ê°€ ê·¸ë ¤ì§€ê³ , ëª‡ëª‡ ì§€ì ì— ëŒ€í•´ ìƒ‰ìƒì„ ì¹ í–ˆìŠµë‹ˆë‹¤.

![Untitled](/assets/(Graphic)11/Untitled%2030.png)

### 3. ì‰ì´ë” ì²˜ë¦¬

ì´ì œ ì‰ì´ë”ì—ì„œ ì²˜ë¦¬í•´ì¤ë‹ˆë‹¤.

ê¸°ì¡´ë§µì„ ê°€ì ¸ì™€ì„œ ë³´ì´ëŠ”ì˜ì—­ì€ rì±„ë„ì˜ ê°’ì„,

êµ½í˜ì²˜ë¦¬ë  ì˜ì—­ì€ gì±„ë„ì˜ ê°’ì„ ê°€ì ¸ì˜¤ë„ë¡ í•©ë‹ˆë‹¤.

ê·¸ë¦¬ê³  êµ½í˜ ì²˜ë¦¬ëœ ì˜ì—­ì€ ë°”ëŒì„ ë°›ì§€ ì•Šë„ë¡ windSampleì—ì„œ í•œë²ˆ ê³±í•´ì£¼ê³ ìš”.

![Untitled](/assets/(Graphic)11/Untitled%2031.png)

ì§œì”

![ì´ ì˜ˆì œëŠ” clamping ì²˜ë¦¬í•˜ì§€ ì•Šì•„ ì²˜ìŒ ì´ë™í• ë•Œ ë°˜ëŒ€ìª½(ì¢Œìƒë‹¨)ì˜ í’€ì´ ì‚¬ë¼ì§ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.](/assets/(Graphic)11/GrassShader.gif)
*ì´ ì˜ˆì œëŠ” clamping ì²˜ë¦¬í•˜ì§€ ì•Šì•„ ì²˜ìŒ ì´ë™í• ë•Œ ë°˜ëŒ€ìª½(ì¢Œìƒë‹¨)ì˜ í’€ì´ ì‚¬ë¼ì§ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.*

![GIF 2022-05-23 17-18-57.gif](/assets/(Graphic)11/GIF_2022-05-23_17-18-57.gif)

ëŒ€ì¶© ì˜ˆì œëŠ” ì´ë ‡ìŠµë‹ˆë‹¤.

```csharp
using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;
using System.Linq;

public class GrassTextureInteraction : MonoBehaviour
{
    [SerializeField]
    private List<Transform> HitTarget;

    [SerializeField]
    private List<Transform> BendTargets;

    [SerializeField]
    private List<Transform> HeightSettingTargets;

    [SerializeField]
    private float reloadRuntime = 0.5f;

    [SerializeField]
    private float heightOverrideValue;

    [SerializeField]
    private float radius;

    [SerializeField]
    private MeshFilter grassGroundMeshFilter;

    [SerializeField]
    private RenderTexture renderTexture;

    private Texture2D texture;

    private readonly List<Vector2> HitPoints = new List<Vector2>();
    private readonly List<Vector2> BendPoints = new List<Vector2>();
    private readonly List<Vector2> HeightSettings = new List<Vector2>();

    void Awake()
    {
        texture = new Texture2D(renderTexture.width, renderTexture.height);
    }

    private void OnEnable()
    {
        //ClearTexture();
        StartCoroutine(UpdateLerping());
    }

    IEnumerator UpdateLerping()
    {
        float t = 0;
        var defaultColors = texture.GetPixels32();
        while (t < reloadRuntime)
        {
            LerpTexture(defaultColors, t / reloadRuntime);
            t += Time.deltaTime;
            yield return null;
        }
    }

    private void FixedUpdate()
    {
        HitPoints.Clear();
        BendPoints.Clear();
        HeightSettings.Clear();
        
        foreach (var target in HitTarget)
        {
            var ray = new Ray(target.position, Vector3.down);

            if (Physics.Raycast(ray, out var hit, 1))
            {
                HitPoints.Add(hit.textureCoord);
            }
        }

        foreach(var target in BendTargets)
        {
            var ray = new Ray(target.position, Vector3.down);

            if (Physics.Raycast(ray, out var hit, 1))
            {
                BendPoints.Add(hit.textureCoord);
            }
        }

        foreach (var target in HeightSettingTargets)
        {
            var ray = new Ray(target.position, Vector3.down);

            if (Physics.Raycast(ray, out var hit, 1))
            {
                HeightSettings.Add(hit.textureCoord);
            }
        }

        ApplyToRenderTexture();
    }

    private void LerpTexture(in Color32[] colors, float t)
    {
        var targetColor = Color.white;
        var list = new List<Color32>();

        foreach (var color in colors)
        {
            list.Add(Color.Lerp(color, Color.white, t));
        }

        texture.SetPixels32(list.ToArray());
        texture.Apply();
    }

    private void ClearTexture()
    {
        Color32 fillColor = Color.white;
        var colors = Enumerable.Repeat(fillColor, texture.width * texture.height).ToArray();

        texture.SetPixels32(colors);
        texture.Apply();
    }

    private void ApplyToRenderTexture()
    {
        var bound = grassGroundMeshFilter.mesh.bounds.size;
        Vector2Int factor = new Vector2Int(
            Mathf.RoundToInt(radius * texture.width / (bound.x * grassGroundMeshFilter.transform.lossyScale.x)),
            Mathf.RoundToInt(radius * texture.height / (bound.z * grassGroundMeshFilter.transform.lossyScale.z)));

        PaintColor(factor, HitPoints, Color.red, 0);
        PaintColor(factor, BendPoints, Color.green, 0);
        PaintColor(factor, HeightSettings, Color.blue, heightOverrideValue);

        texture.Apply();

        Graphics.Blit(texture, renderTexture);
    }

    void PaintColor(in Vector2Int factor, in List<Vector2> points, in Color mask, in float value)
    {
        foreach (var point in points)
        {
            var pos = new Vector2Int(Mathf.FloorToInt(point.x * texture.width), Mathf.FloorToInt(point.y * texture.height));

            var xMin = Mathf.Clamp(pos.x - factor.x, 0, texture.width);
            var xMax = Mathf.Clamp(pos.x + factor.x, 0, texture.width);
            var yMin = Mathf.Clamp(pos.y - factor.y, 0, texture.height);
            var yMax = Mathf.Clamp(pos.y + factor.y, 0, texture.height);

            for (int x = xMin; x < xMax; ++x)
            {
                for (int y = yMin; y < yMax; ++y)
                {
                    var color = texture.GetPixel(x, y);

                    color -= color * mask;
                    color += mask * value;

                    texture.SetPixel(x, y, color);
                }
            }
        }
    }
}
```